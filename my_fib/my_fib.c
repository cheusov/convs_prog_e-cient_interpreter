/*
 * Permission is hereby granted, free of charge, to any person or
 * organization obtaining a copy of the software and accompanying
 * documentation covered by this license (the "Software") to use,
 * reproduce, display, distribute, execute, and transmit the Software,
 * and to prepare derivative works of the Software, and to permit
 * third-parties to whom the Software is furnished to do so, all subject
 * to the following:
 *
 * The copyright notices in the Software and this entire statement,
 * including the above license grant, this restriction and the following
 * disclaimer, must be included in all copies of the Software, in whole
 * or in part, and all derivative works of the Software, unless such
 * copies or derivative works are solely in the form of
 * machine-executable object code generated by a source language
 * processor.
 *
 * THE SOFTWARE IS PROVIDED “AS IS”, WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, TITLE AND
 * NON-INFRINGEMENT. IN NO EVENT SHALL THE COPYRIGHT HOLDERS OR ANYONE
 * DISTRIBUTING THE SOFTWARE BE LIABLE FOR ANY DAMAGES OR OTHER
 * LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT
 * OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <assert.h>
#include <getopt.h>
#include <string.h>

#include "threaded_code.h"
#include "interp.h"
#include "svm.h"
#include "rvm.h"

#define DATA_STACK_SIZE 1000
#define RETURN_STACK_SIZE 1000

static void fibonacci_svm_v1(unsigned n) {
	SVM_PUSH(n);
	SVM_CALL("Fibonacci");
	SVM_PRINTLN_UINT;
	SVM_EXIT;

	// fib
	// n | Fib(n)
	LABEL("Fibonacci");

	// n
	SVM_DUP;
	// n, n
	SVM_PUSH(1);
	// n, n, 1
	SVM_EQ;
	// n, n == 1
	SVM_JUMP_IF_NOTZERO("return 1");
	// n
	SVM_DUP;
	// n, n
	SVM_PUSH(0);
	// n, n, 0
	SVM_EQ;
	// n, n == 0
	SVM_JUMP_IF_NOTZERO("return 0");
	// n
	SVM_DEC;
	// n - 1
	SVM_DUP;
	// n - 1, n - 1
	SVM_DEC;
	// n - 1, n - 2
	SVM_CALL("Fibonacci");
	// n - 1, Fib(n - 2)
	SVM_SWAP;
	// Fib(n - 2), n - 1
	SVM_CALL("Fibonacci");
	// Fib(n - 2), Fib(n - 1)
	SVM_ADD_UINT;
	// Fib(n - 2) + Fib(n - 1)
	SVM_RET;

	//
	LABEL("return 1");

	// n
	SVM_DROP;
	//
	SVM_PUSH(1);
	// 1
	SVM_RET;

	//
	LABEL("return 0");

	// n
	SVM_DROP;
	//
	SVM_PUSH(0);
	// 0
	SVM_RET;

	tc_resolve();
}

static void fibonacci_svm_v2(unsigned n) {
	SVM_PUSH(n);
	SVM_CALL("Fibonacci");
	SVM_PRINTLN_UINT;
	SVM_EXIT;

	// fib
	// n | Fib(n)
	______Function______("Fibonacci");

	// n
	SVM_JUMP_AND_DROP_IF_EQ_CONST(1, "return 1");
	// n
	SVM_JUMP_AND_DROP_IF_ZERO("return 0");
	// n
	SVM_DEC;
	// n - 1
	SVM_DUP;
	// n - 1, n - 1
	SVM_DEC;
	// n - 1, n - 2
	SVM_CALL("Fibonacci");
	// n - 1, Fib(n - 2)
	SVM_SWAP;
	// Fib(n - 2), n - 1
	SVM_CALL("Fibonacci");
	// Fib(n - 2), Fib(n - 1)
	SVM_ADD_UINT;
	// Fib(n - 2) + Fib(n - 1)
	SVM_RET;

	//
	______("return 1");
	SVM_PUSH_RET(1);

	//
	______("return 0");
	SVM_PUSH_RET(0);

	tc_resolve();
}

static void fibonacci_svm_v3(unsigned n) {
	SVM_PUSH(n);
	SVM_CALL("Fibonacci");
	SVM_PRINTLN_UINT;
	SVM_EXIT;

	// fib
	// n | Fib(n)
	______Function______("Fibonacci");

	// n
	SVM_DUP_JUMP_IF_EQ_CONST(1, "return n");
	// n
	SVM_DUP_JUMP_IF_ZERO("return n");
	// n
	SVM_DEC;
	// n - 1
	SVM_DUP;
	// n - 1, n - 1
	SVM_DEC;
	// n - 1, n - 2
	SVM_CALL("Fibonacci");
	// n - 1, Fib(n - 2)
	SVM_SWAP;
	// Fib(n - 2), n - 1
	SVM_CALL("Fibonacci");
	// Fib(n - 2), Fib(n - 1)
	SVM_ADD_UINT;
	// Fib(n - 2) + Fib(n - 1)
	SVM_RET;

	// n
	______("return n");
	SVM_RET;

	tc_resolve();
}

static void fibonacci_svm_v4(unsigned n) {
	SVM_PUSH(n);
	SVM_CALL("Fibonacci");
	SVM_PRINTLN_UINT;
	SVM_EXIT;

	// fib
	// n | Fib(n)
	______Function______("Fibonacci");

	// n
	SVM_DUP_JUMP_IF_LE_CONST(1, "return n");
	// n
	SVM_DEC;
	// n - 1
	SVM_DUP;
	// n - 1, n - 1
	SVM_DEC;
	// n - 1, n - 2
	SVM_CALL("Fibonacci");
	// n - 1, Fib(n - 2)
	SVM_SWAP;
	// Fib(n - 2), n - 1
	SVM_CALL("Fibonacci");
	// Fib(n - 2), Fib(n - 1)
	SVM_ADD_UINT;
	// Fib(n - 2) + Fib(n - 1)
	SVM_RET;

	// n
	______("return n");
	SVM_RET;

	tc_resolve();
}

static void fibonacci_rvm_v1(unsigned n, unsigned global_var_count) {
	dsp += global_var_count;

	RVM_SET(17, n);
	RVM_CALL1(10, 17, "Fibonacci");
	RVM_PRINTLN_UINT(10);
	SVM_EXIT;

	______Function______("Fibonacci");
	RVM_FRAMESIZE(4); // frame size
	RVM_JUMP_IF_ZERO(2, "return n");
	RVM_JUMP_IF_EQ_CONST(2, 1, "return n");
	RVM_DEC(2, 2);
	RVM_DEC(3, 2);
	RVM_CALL1(2, 2, "Fibonacci");
	RVM_CALL1(3, 3, "Fibonacci");
	RVM_ADD(2, 3, 2);

	______("return n");
	RVM_RET(2);

	tc_resolve();
}

static void fibonacci_rvm_v2(unsigned n, unsigned global_var_count) {
	dsp += global_var_count;

	RVM_SET(17, n);
	RVM_CALL1(10, 17, "Fibonacci");
	RVM_PRINTLN_UINT(10);
	SVM_EXIT;

	______Function______("Fibonacci");
	RVM_FRAMESIZE(4); // frame size
	RVM_JUMP_IF_ZERO(2, "return n");
	RVM_JUMP_IF_EQ_CONST(2, 1, "return n");
	RVM_DEC1(2);
	RVM_DEC(3, 2);
	RVM_CALL1(2, 2, "Fibonacci");
	RVM_CALL1(3, 3, "Fibonacci");
	RVM_ADD1(2, 3);

	______("return n");
	RVM_RET(2);

	tc_resolve();
}

static void fibonacci_rvm_v3(unsigned n, unsigned global_var_count) {
	dsp += global_var_count;

	RVM_SET(17, n);
	RVM_CALL1(10, 17, "Fibonacci");
	RVM_PRINTLN_UINT(10);
	SVM_EXIT;

	______Function______("Fibonacci");
	RVM_FRAMESIZE(4); // frame size
	RVM_JUMP_IF_LE_CONST(2, 1, "return n");
	RVM_DEC1(2);
	RVM_DEC(3, 2);
	RVM_CALL1(2, 2, "Fibonacci");
	RVM_CALL1(3, 3, "Fibonacci");
	RVM_ADD1(2, 3);

	______("return n");
	RVM_RET(2);

	tc_resolve();
}

static void test_threaded_code(void) {
	SVM_PUSH(100);
	SVM_CALL("MyDup");
	SVM_PRINTLN_UINT;
	SVM_PRINTLN_UINT;
	SVM_EXIT;

	// fib
	// n | Fib(n)
	______Function______("MyDup");
	SVM_DUP;
	SVM_DEC;
	SVM_RET;

	tc_resolve();
}

static void usage(void)
{
	fprintf(stderr, "usage: my_fib [OPTIONS]\n\
OPTIONS:\n\
   -h     -- display this screen\n\
\n\
   -n <num>     -- calculate Fib(n), the default is 28\n\
   -c <count>   -- repeat calculation count times, the default is 1000\n\
\n\
   -s1    -- Forth-like threaded code (Stack-based VM v1)\n\
   -s2    -- SVM v2\n\
   -s3    -- SVM v3\n\
   -s4    -- SVM v4\n\
\n\
   -r1    -- register-based VM v1\n\
   -r2    -- RVM v2\n\
   -r3    -- RVM v3\n\
\n\
   -t    -- threaded code for testing\n\
\n\
Examples:\n\
   $ time -p my_fib -s1 >/dev/null\n\
   $ time -p my_fib -s2 >/dev/null\n\
   $ time -p my_fib -r1 >/dev/null\n\
");
}

typedef enum {
	NONE,

	SVM_V1,
	SVM_V2,
	SVM_V3,
	SVM_V4,

	RVM_V1,
	RVM_V2,
	RVM_V3,

	TEST,
} threaded_code_type;

int main(int argc, char** argv) {
	int opt;

	int n = 28;
	int count = 1000;

	tc_init();
	interp_init();
	threaded_code_type op = NONE;

	while ((opt = getopt(argc, argv, "+c:hn:r:s:t")) != -1) {
		switch (opt) {
			case 'h':
				usage();
				exit(0);
			case 's':
				if (!strcmp("1", optarg)) {
					op = SVM_V1;
				} else if (!strcmp("2", optarg)) {
					op = SVM_V2;
				} else if (!strcmp("3", optarg)) {
					op = SVM_V3;
				} else if (!strcmp("4", optarg)) {
					op = SVM_V4;
				} else {
					abort();
				}
				break;
			case 'r':
				if (!strcmp("1", optarg)) {
					op = RVM_V1;
				} else if (!strcmp("2", optarg)) {
					op = RVM_V2;
				} else if (!strcmp("3", optarg)) {
					op = RVM_V3;
				} else {
					abort();
				}
				break;
			case 't':
				op = TEST;
				count = 2;
				break;
			case 'c':
				count = atoi(optarg);
				break;
			case 'n':
				n = atoi(optarg);
				break;
			default:
				usage();
				exit(1);
		}
	}

	switch (op) {
		case SVM_V1:
			fibonacci_svm_v1(n);
			break;
		case SVM_V2:
			fibonacci_svm_v2(n);
			break;
		case SVM_V3:
			fibonacci_svm_v3(n);
			break;
		case SVM_V4:
			fibonacci_svm_v4(n);
			break;
		case RVM_V1:
			fibonacci_rvm_v1(n, 100);
			break;
		case RVM_V2:
			fibonacci_rvm_v2(n, 100);
			break;
		case RVM_V3:
			fibonacci_rvm_v3(n, 100);
			break;
		case TEST:
			test_threaded_code();
			break;
		case NONE:
			fprintf(stderr, "Either of the following options must be applied: -r, -s or -t\n");
			exit(2);
			break;
		default:
			abort();
	}

	// Run interpreter
	uintptr_t *orig_dsp = dsp;
	for (int i = 0; i < count; ++i) {
		ip = tc;
		interp_run();
		assert(dsp == orig_dsp);
	}

	interp_destroy();
	tc_destroy();
	return 0;
}
