/*
 * Permission is hereby granted, free of charge, to any person or
 * organization obtaining a copy of the software and accompanying
 * documentation covered by this license (the "Software") to use,
 * reproduce, display, distribute, execute, and transmit the Software,
 * and to prepare derivative works of the Software, and to permit
 * third-parties to whom the Software is furnished to do so, all subject
 * to the following:
 *
 * The copyright notices in the Software and this entire statement,
 * including the above license grant, this restriction and the following
 * disclaimer, must be included in all copies of the Software, in whole
 * or in part, and all derivative works of the Software, unless such
 * copies or derivative works are solely in the form of
 * machine-executable object code generated by a source language
 * processor.
 *
 * THE SOFTWARE IS PROVIDED “AS IS”, WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, TITLE AND
 * NON-INFRINGEMENT. IN NO EVENT SHALL THE COPYRIGHT HOLDERS OR ANYONE
 * DISTRIBUTING THE SOFTWARE BE LIABLE FOR ANY DAMAGES OR OTHER
 * LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT
 * OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

#include <stddef.h>
#include <stdio.h>
#include <stdlib.h>
#include <assert.h>
#include <string.h>

#include "threaded_code.h"

#define TC_SIZE 1000
#define LABEL_COUNT 100
#define JUMP_COUNT 200

uintptr_t tc[TC_SIZE];
static unsigned tc_offset = 0;

static const char *labels[LABEL_COUNT];
static unsigned label_offsets[sizeof(labels)/sizeof(labels[0])];
static size_t label_count = 0;

static const char *jump_labels[JUMP_COUNT];
static unsigned jump_offsets[sizeof(jump_labels)/sizeof(jump_labels[0])];
static size_t jump_count = 0;

void tc_insert_value(uintptr_t value) {
	if (tc_offset == sizeof(tc)/sizeof(tc[0])) {
		fprintf(stderr, "Too many commands in threaded code\n");
		exit(2);
	}
	tc[tc_offset++] = value;
}

void tc_insert_call(command_t f) {
	tc_insert_value((uintptr_t) f);
}

void tc_insert_call1(command_t f, uintptr_t value) {
	tc_insert_call(f);
	tc_insert_value(value);
}

void tc_insert_call2(command_t f, uintptr_t v1, uintptr_t v2) {
	tc_insert_call(f);
	tc_insert_value(v1);
	tc_insert_value(v2);
}

void tc_insert_call3(command_t f, uintptr_t v1, uintptr_t v2, uintptr_t v3) {
	tc_insert_call(f);
	tc_insert_value(v1);
	tc_insert_value(v2);
	tc_insert_value(v3);
}

static void tc_add_jump(const char *jump) {
	if (jump_count == sizeof(jump_labels)/sizeof(jump_labels[0])) {
		fprintf(stderr, "Too many jumps\n");
		exit(4);
	}
	jump_labels[jump_count] = jump;
	jump_offsets[jump_count] = tc_offset;
	++jump_count;
}

void tc_insert_jump1(command_t f, const char *jump) {
	tc_insert_call(f);
	tc_add_jump(jump);
	tc_insert_value(-1);
}

void tc_insert_jump2(command_t f, uintptr_t value, const char *jump) {
	tc_insert_call(f);
	tc_insert_value(value);
	tc_add_jump(jump);
	tc_insert_value(-1);
}

void tc_insert_jump3(command_t f, uintptr_t v1, uintptr_t v2, const char *jump) {
	tc_insert_call(f);
	tc_insert_value(v1);
	tc_insert_value(v2);
	tc_add_jump(jump);
	tc_insert_value(-1);
}

void tc_label(const char *label) {
	if (label_count == sizeof(labels)/sizeof(labels[0])) {
		fprintf(stderr, "Too many labels\n");
		exit(3);
	}

	labels[label_count] = label;
	label_offsets[label_count] = tc_offset;
	++label_count;
}

void tc_resolve(void) {
	// O(n*m) I know, this is very inefficient
	for (size_t jn = 0; jn < jump_count; ++jn) {
		size_t ln;
		for (ln = 0; ln < label_count; ++ln) {
			if (!strcmp(labels[ln], jump_labels[jn])) {
				tc[jump_offsets[jn]] = (uintptr_t) (tc + label_offsets[ln]);
				break;
			}
		}
		if (ln == label_count) {
			fprintf(stderr, "Unresolved link %s\n", jump_labels[jn]);
			exit(1);
		}
	}
}

void tc_init(void) {
}

void tc_destroy(void) {
}
