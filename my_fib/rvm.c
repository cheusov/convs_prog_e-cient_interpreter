/*
 * Permission is hereby granted, free of charge, to any person or
 * organization obtaining a copy of the software and accompanying
 * documentation covered by this license (the "Software") to use,
 * reproduce, display, distribute, execute, and transmit the Software,
 * and to prepare derivative works of the Software, and to permit
 * third-parties to whom the Software is furnished to do so, all subject
 * to the following:
 *
 * The copyright notices in the Software and this entire statement,
 * including the above license grant, this restriction and the following
 * disclaimer, must be included in all copies of the Software, in whole
 * or in part, and all derivative works of the Software, unless such
 * copies or derivative works are solely in the form of
 * machine-executable object code generated by a source language
 * processor.
 *
 * THE SOFTWARE IS PROVIDED “AS IS”, WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, TITLE AND
 * NON-INFRINGEMENT. IN NO EVENT SHALL THE COPYRIGHT HOLDERS OR ANYONE
 * DISTRIBUTING THE SOFTWARE BE LIABLE FOR ANY DAMAGES OR OTHER
 * LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT
 * OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

#include <stdio.h>
#include <stdint.h>

#include "rvm.h"
#include "interp.h"
#include "threaded_code.h"

CMD_IMPLEMENTATION(rvm_call) {
	int result_reg = (int) *ip++;
	int arg_reg = (int) *ip++;
	uintptr_t* jump_to = (uintptr_t*) *ip++;
	unsigned frame_size = *jump_to++; // frame size from callee's threaded code
	uintptr_t arg = dsp[arg_reg];
	uintptr_t* new_dsp = dsp + frame_size;
	new_dsp[0] = frame_size;
	new_dsp[-1] = result_reg;
	new_dsp[-2] = arg;
#if !DIRECT_THREADED_CODE
	dsp = new_dsp;
	* ++rsp = (uintptr_t) ip;
	ip = jump_to;
#elif IP_DSP_REGISTERS
	command_t func = (command_t) *jump_to++;
	func(jump_to, new_dsp);
#else
	uintptr_t* old_ip = ip;
	ip = jump_to;
	command_t func = (command_t) *ip++;
	dsp = new_dsp;
	func();
	ip = old_ip;
#endif
} CMD_END

CMD_IMPLEMENTATION(rvm_ret) {
	int return_reg = (int) *ip++; // callee's result register
	uintptr_t return_value = dsp[return_reg];
	unsigned frame_size = (unsigned) *dsp;
	int result_reg = (int) dsp[-1]; // // caller's result register
	dsp -= frame_size;
	dsp[result_reg] = return_value; // copy result to the caller
#if DIRECT_THREADED_CODE
	return;
#else
	ip = (uintptr_t*) *rsp--;
#endif
} CMD_END

CMD_IMPLEMENTATION(rvm_println_uint) {
	int arg_reg = (int) *ip++;
	printf("%u\n", (unsigned)dsp[arg_reg]);
} CMD_END

CMD_IMPLEMENTATION(rvm_set) {
	int result_reg = (int) *ip++;
	uintptr_t value = *ip++;
	dsp[result_reg] = value;
} CMD_END

CMD_IMPLEMENTATION(rvm_dec) {
	int result_reg = (int) *ip++;
	int arg_reg = (int) *ip++;
	dsp[result_reg] = dsp[arg_reg] - 1;
} CMD_END

CMD_IMPLEMENTATION(rvm_dec1) {
	int result_reg = (int) *ip++;
	--dsp[result_reg];
} CMD_END

CMD_IMPLEMENTATION(rvm_add) {
	int result_reg = (int) *ip++;
	int a_reg = (int) *ip++;
	int b_reg = (int) *ip++;
	dsp[result_reg] = dsp[a_reg] + dsp[b_reg];
} CMD_END

CMD_IMPLEMENTATION(rvm_add1) {
	int result_reg = (int) *ip++;
	int value_reg = (int) *ip++;
	dsp[result_reg] += dsp[value_reg];
} CMD_END

#if DIRECT_THREADED_CODE
void rvm_exit(TAKE_ARGS) {
	return;
}
#else
CMD_IMPLEMENTATION(rvm_exit) {
	ip = NULL;
} CMD_END
#endif

CMD_IMPLEMENTATION(rvm_jump_if_zero) {
	int arg_reg = (int) *ip++;
	uintptr_t jump_to = *ip++;
	if (!dsp[arg_reg]) {
		ip = (uintptr_t*) jump_to;
	}
} CMD_END

CMD_IMPLEMENTATION(rvm_jump_if_eq_const) {
	int arg_reg = (int) *ip++;
	uintptr_t value = *ip++;
	uintptr_t* jump_to = (uintptr_t*) *ip++;
	if (dsp[arg_reg] == value) {
		ip = jump_to;
	}
} CMD_END

CMD_IMPLEMENTATION(rvm_jump_if_le_const) {
	int arg_reg = (int) *ip++;
	uintptr_t value = *ip++;
	uintptr_t jump_to = *ip++;
	if (dsp[arg_reg] <= value) {
		ip = (uintptr_t*) jump_to;
	}
} CMD_END
