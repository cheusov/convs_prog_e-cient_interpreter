/*
 * Permission is hereby granted, free of charge, to any person or
 * organization obtaining a copy of the software and accompanying
 * documentation covered by this license (the "Software") to use,
 * reproduce, display, distribute, execute, and transmit the Software,
 * and to prepare derivative works of the Software, and to permit
 * third-parties to whom the Software is furnished to do so, all subject
 * to the following:
 *
 * The copyright notices in the Software and this entire statement,
 * including the above license grant, this restriction and the following
 * disclaimer, must be included in all copies of the Software, in whole
 * or in part, and all derivative works of the Software, unless such
 * copies or derivative works are solely in the form of
 * machine-executable object code generated by a source language
 * processor.
 *
 * THE SOFTWARE IS PROVIDED “AS IS”, WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, TITLE AND
 * NON-INFRINGEMENT. IN NO EVENT SHALL THE COPYRIGHT HOLDERS OR ANYONE
 * DISTRIBUTING THE SOFTWARE BE LIABLE FOR ANY DAMAGES OR OTHER
 * LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT
 * OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <sys/mman.h>

#include "defs.h"
#include "threaded_code.h"
#include "interp.h"

#define DATA_STACK_SIZE 1000
#define RETURN_STACK_SIZE 1000
#define PAGE_SIZE 4096

static void* allocate_pages(size_t pcount) {
	// Allocate zero-ed pcount+2 pages and then disable access to the
	// first and the last pages in order to be informed about
	// overflow/underflow of data- or return stacks.
	char* p = mmap(0, (pcount + 2) * PAGE_SIZE, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0);
	if (p == MAP_FAILED) {
		perror("mmap(2) failed");
	}
	if (mprotect(p, PAGE_SIZE, PROT_NONE)) {
		perror("mprotect(2) failed");
	}
	if (mprotect(p + (pcount + 1) * PAGE_SIZE, PAGE_SIZE, PROT_NONE)) {
		perror("mprotect(2) failed");
	}

	return p + PAGE_SIZE;
}

static void deallocate_pages(void *p, size_t pcount) {
	if (munmap((char*) p - PAGE_SIZE, (pcount + 2) * PAGE_SIZE)) {
		perror("munmap(2) failed");
	}
}

void interp_run(void) {
#if DIRECT_THREADED_CODE
	command_t func = (command_t) *ip++;
	func(PASS_ARGS);
#else
	while (ip) {
		command_t func = (command_t) *ip++;
		func();
	}
#endif
}

static uintptr_t* ds = NULL; // data stack (grows upword!)
#if !DIRECT_THREADED_CODE
static uintptr_t* rs = NULL; // return stack (grows upword!)
#endif

uintptr_t* ip = NULL;
uintptr_t* dsp = NULL;
#if !DIRECT_THREADED_CODE
uintptr_t* rsp = NULL;
#endif

#define BYTES2PAGES(x) ((x) + PAGE_SIZE - 1) / PAGE_SIZE

static size_t ds_pages = 0;
#if !DIRECT_THREADED_CODE
static size_t rs_pages = 0;
#endif

void interp_init(void) {
	ds_pages = BYTES2PAGES(DATA_STACK_SIZE * sizeof(ds[0]));
	ds = allocate_pages(ds_pages);
	dsp = ds - 1;
#if !DIRECT_THREADED_CODE
	rs_pages = BYTES2PAGES(RETURN_STACK_SIZE * sizeof(rs[0]));
	rs = allocate_pages(rs_pages);
	rsp = rs - 1;
#endif

	ip = tc;
}

void interp_destroy(void) {
	deallocate_pages(ds, ds_pages);
#if !DIRECT_THREADED_CODE
	deallocate_pages(rs, rs_pages);
#endif
}

size_t interp_page_size(void) {
	return PAGE_SIZE;
}
